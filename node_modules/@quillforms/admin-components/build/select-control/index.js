"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _element = require("@wordpress/element");
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _downshift = require("downshift");
var _classnames = _interopRequireDefault(require("classnames"));
var _icons = require("@wordpress/icons");
var _i18n = require("@wordpress/i18n");
var _react = require("react");
var _reactDom = require("react-dom");
var _components = require("@wordpress/components");
// Forked from @WordPress/components and added a feature of supporting item labels as React components.
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const itemToString = item => {
  if (item?.name) {
    if (typeof item.name === 'string') {
      return item.name;
    }
    const span = document.createElement('span');
    (0, _reactDom.render)(item.name, span);
    const tmp = document.createElement('div');
    tmp.appendChild(span);
    // @ts-expect-error
    return tmp.children[0]?.innerText;
    // var div = document.createElement( 'div' );
    // div.innerHTML = reactToHtmlString;
    // return div.textContent || div.innerText || '';
  }

  return undefined;
};
// This is needed so that in Windows, where
// the menu does not necessarily open on
// key up/down, you can still switch between
// options with the menu closed.
const stateReducer = (_ref, _ref2) => {
  let {
    selectedItem
  } = _ref;
  let {
    type,
    changes,
    props: {
      items
    }
  } = _ref2;
  switch (type) {
    case _downshift.useSelect.stateChangeTypes.ToggleButtonKeyDownArrowDown:
      // If we already have a selected item, try to select the next one,
      // without circular navigation. Otherwise, select the first item.
      return {
        selectedItem: items[selectedItem ? Math.min(items.indexOf(selectedItem) + 1, items.length - 1) : 0]
      };
    case _downshift.useSelect.stateChangeTypes.ToggleButtonKeyDownArrowUp:
      // If we already have a selected item, try to select the previous one,
      // without circular navigation. Otherwise, select the last item.
      return {
        selectedItem: items[selectedItem ? Math.max(items.indexOf(selectedItem) - 1, 0) : items.length - 1]
      };
    default:
      return changes;
  }
};
const SelectControl = _ref3 => {
  let {
    /** Start opting into the larger default height that will become the default size in a future version. */
    // @ts-expect-error
    __next36pxDefaultSize = false,
    className,
    // @ts-expect-error
    hideLabelFromVision,
    label,
    // @ts-expect-error
    describedBy,
    options: items,
    onChange: onSelectedItemChange,
    value: _selectedItem
  } = _ref3;
  const {
    getLabelProps,
    getToggleButtonProps,
    getMenuProps,
    getItemProps,
    isOpen,
    highlightedIndex,
    selectedItem
  } = (0, _downshift.useSelect)({
    // @ts-expect-error
    initialSelectedItem: items[0],
    // @ts-expect-error
    items,
    itemToString,
    onSelectedItemChange,
    ...(typeof _selectedItem !== 'undefined' && _selectedItem !== null ? {
      selectedItem: _selectedItem
    } : undefined),
    // @ts-ignore
    stateReducer
  });
  function getDescribedBy() {
    if (describedBy) {
      return describedBy;
    }
    if (!selectedItem) {
      return (0, _i18n.__)('No selection');
    }

    // translators: %s: The selected option.
    return (0, _i18n.sprintf)((0, _i18n.__)('Currently selected: %s'), selectedItem.name);
  }
  const menuProps = getMenuProps({
    className: 'components-custom-select-control__menu',
    'aria-hidden': !isOpen
  });
  const onKeyDownHandler = (0, _react.useCallback)(e => {
    e.stopPropagation();
    menuProps?.onKeyDown?.(e);
  }, [menuProps]);

  // We need this here, because the null active descendant is not fully ARIA compliant.
  if (menuProps['aria-activedescendant']?.startsWith('downshift-null')) {
    delete menuProps['aria-activedescendant'];
  }
  return (0, _element.createElement)("div", {
    className: "admin-components-select-control"
  }, (0, _element.createElement)("div", {
    className: (0, _classnames.default)('components-custom-select-control', className)
  }, hideLabelFromVision ? (0, _element.createElement)(_components.VisuallyHidden, (0, _extends2.default)({
    as: "label"
  }, getLabelProps()), label) : /* eslint-disable-next-line jsx-a11y/label-has-associated-control, jsx-a11y/label-has-for */
  (0, _element.createElement)("label", getLabelProps({
    className: 'components-custom-select-control__label'
  }), label), (0, _element.createElement)(_components.Button, getToggleButtonProps({
    // This is needed because some speech recognition software don't support `aria-labelledby`.
    'aria-label': label,
    'aria-labelledby': undefined,
    className: (0, _classnames.default)('components-custom-select-control__button', {
      'is-next-36px-default-size': __next36pxDefaultSize
    }),
    // @ts-expect-error
    describedBy: getDescribedBy()
  }), selectedItem?.name, (0, _element.createElement)(_icons.Icon, {
    icon: _icons.chevronDown,
    className: (0, _classnames.default)('components-custom-select-control__button-icon', {
      'is-next-36px-default-size': __next36pxDefaultSize
    }),
    size: 18
  })), (0, _element.createElement)("ul", (0, _extends2.default)({}, menuProps, {
    onKeyDown: onKeyDownHandler
  }), isOpen &&
  // @ts-expect-error
  items.map((item, index) => {
    //console.log( item );
    return (
      // eslint-disable-next-line react/jsx-key
      (0, _element.createElement)("li", getItemProps({
        item,
        index,
        key: item.key,
        className: (0, _classnames.default)(item.className, 'components-custom-select-control__item', {
          'is-highlighted': index === highlightedIndex,
          'has-hint': !!item.__experimentalHint,
          'is-next-36px-default-size': __next36pxDefaultSize
        }),
        style: item.style
      }), item.name, item.__experimentalHint && (0, _element.createElement)("span", {
        className: "components-custom-select-control__item-hint"
      }, item.__experimentalHint), item === selectedItem && (0, _element.createElement)(_icons.Icon, {
        icon: _icons.check,
        className: "components-custom-select-control__item-icon"
      }))
    );
  }))));
};
var _default = SelectControl;
exports.default = _default;
//# sourceMappingURL=index.js.map