"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _element = require("@wordpress/element");
var _data = require("@wordpress/data");
var _hooks = require("@wordpress/hooks");
var _classnames = _interopRequireDefault(require("classnames"));
var _reactSwipeable = require("react-swipeable");
var _lethargy = require("lethargy");
var _fieldRender = _interopRequireDefault(require("../field-render"));
var _hooks2 = require("../../hooks");
/* eslint-disable no-nested-ternary */
/**
 * Wordpress Dependencies
 */

/**
 * External Dependencies
 */

/**
 * Internal Dependencies
 */

let lastScrollDate = 0;
const lethargy = new _lethargy.Lethargy();
const FieldsWrapper = _ref => {
  let {
    applyLogic,
    isActive
  } = _ref;
  const {
    beforeGoingNext
  } = (0, _hooks2.useFormContext)();
  const blocks = (0, _hooks2.useBlocks)();
  const blockTypes = (0, _hooks2.useBlockTypes)();
  const logic = (0, _hooks2.useLogic)();
  const hiddenFields = (0, _hooks2.useHiddenFields)();
  const settings = (0, _hooks2.useFormSettings)();
  const ref = (0, _element.useRef)(null);
  const {
    swiper
  } = (0, _data.useSelect)(select => {
    return {
      swiper: select('quillForms/renderer-core').getSwiperState()
    };
  });
  const {
    walkPath,
    currentBlockId,
    nextBlockId,
    prevBlockId,
    lastActiveBlockId,
    canSwipeNext,
    canSwipePrev,
    isAnimating,
    isCurrentBlockSafeToSwipe
  } = swiper;
  const {
    answers
  } = (0, _data.useSelect)(select => {
    return {
      answers: select('quillForms/renderer-core').getAnswers()
    };
  });
  const currentBlockIndex = walkPath.findIndex(block => block.id === currentBlockId);
  const currentBlockName = walkPath[currentBlockIndex]?.name;
  const currentBlockType = blockTypes?.[currentBlockName];
  const lastActiveBlockIndex = walkPath.findIndex(block => block.id === lastActiveBlockId);
  const isTouchScreen = typeof window !== 'undefined' && 'ontouchstart' in window || typeof navigator !== 'undefined' && navigator.maxTouchPoints > 0 ||
  // @ts-expect-error
  typeof navigator !== 'undefined' && navigator.msMaxTouchPoints > 0;
  const getFieldsToRender = () => {
    const fieldIds = [];
    const filteredBlocks = walkPath.filter(block => answers[block.id]?.isPending || block.id === currentBlockId || !isTouchScreen && block.id === nextBlockId || !isTouchScreen && block.id === prevBlockId || !isTouchScreen && block.id === lastActiveBlockId);
    filteredBlocks.forEach(block => {
      if (block.name !== 'welcome-screen' && block.name !== 'thankyou-screen') {
        fieldIds.push(block.id);
      }
    });
    return fieldIds;
  };
  const fieldsToRender = getFieldsToRender();
  const fields = walkPath.filter(block => block.name !== 'welcome-screen' && block.name !== 'thankyou-screen');
  const {
    setSwiper,
    goNext,
    goPrev,
    goToBlock,
    setIsCurrentBlockSafeToSwipe,
    setIsFieldValid,
    setIsFieldPending,
    setFieldValidationErr
  } = (0, _data.useDispatch)('quillForms/renderer-core');
  const goNextReally = async () => {
    if (answers[currentBlockIndex]?.isPending) return;
    if (beforeGoingNext && currentBlockId) {
      await beforeGoingNext({
        answers,
        currentBlockId,
        setIsFieldValid,
        setFieldValidationErr,
        setIsCurrentBlockSafeToSwipe,
        goToBlock,
        goNext,
        setIsPending: val => setIsFieldPending(currentBlockId, val)
      });
    } else {
      goNext();
    }
  };
  const {
    isCurrentBlockValid
  } = (0, _data.useSelect)(select => {
    return {
      isCurrentBlockValid: currentBlockType?.supports?.innerBlocks ? select('quillForms/renderer-core')?.hasValidFields(
      // @ts-expect-error
      currentBlockId) : currentBlockType?.supports?.editable ? select('quillForms/renderer-core')?.isValidField(
      // @ts-expect-error
      currentBlockId) : true
    };
  });
  (0, _element.useEffect)(() => {
    if (isCurrentBlockSafeToSwipe) setIsCurrentBlockSafeToSwipe(true);
  }, [isCurrentBlockValid]);
  const isFirstField = walkPath?.length > 0 && walkPath[0].id === currentBlockId;
  const isLastField = walkPath?.length && currentBlockId === walkPath[walkPath.length - 1].id;
  const handlers = (0, _reactSwipeable.useSwipeable)({
    onSwiping: e => {
      swipingHandler(e, true);
    },
    preventDefaultTouchmoveEvent: false,
    trackMouse: false,
    trackTouch: true,
    delta: 70
  });

  // Mouse Wheel Handler
  const swipingHandler = function (e) {
    let touch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (settings?.disableWheelSwiping) return;
    let delta = e.deltaY;
    if (settings?.animationDirection === 'horizontal') {
      delta = e.deltaX;
    }
    if (swiper.isAnimating) return;
    const lethargyCheck = lethargy.check(e);
    const now = new Date().getTime();
    let timeDelay = 900;
    if (touch) timeDelay = 500;
    if (lethargyCheck === false || isAnimating || lastScrollDate && now - lastScrollDate < timeDelay) return;
    if (canSwipePrev && (delta < -50 && !touch || touch && delta > 50 && e.dir === 'Down') && !isFirstField) {
      // Scroll up
      lastScrollDate = new Date().getTime();
      goPrev();
    } else if (canSwipeNext && (delta < -50 && touch && e.dir === 'Up' || !touch && delta > 50) && !isLastField) {
      lastScrollDate = new Date().getTime();
      // Scroll down
      if (isCurrentBlockValid) {
        goNextReally();
      } else {
        setIsCurrentBlockSafeToSwipe(false);
      }
    }
  };
  (0, _element.useEffect)(() => {
    if (isAnimating) {
      const timer = setTimeout(() => {
        setSwiper({
          isAnimating: false
        });
      }, 600);
      return () => clearTimeout(timer);
    }
  }, [swiper]);
  (0, _element.useEffect)(() => {
    if (applyLogic && isActive) {
      (0, _hooks.doAction)('QuillForms.RendererCore.LogicApply', blocks, blockTypes, logic, hiddenFields);
    }
  }, [answers, currentBlockId]);
  (0, _element.useEffect)(() => {
    if (applyLogic && isActive) {
      setSwiper({
        currentBlockId: blocks[0].id,
        prevBlockId: undefined,
        canSwipePrev: false,
        lastActiveBlockId: undefined
      });
      (0, _hooks.doAction)('QuillForms.RendererCore.LogicApply', blocks, blockTypes, logic, hiddenFields);
    }
    if (!applyLogic) {
      (0, _hooks.doAction)('QuillForms.RendererCore.LogicTurnOff');
    }
  }, [applyLogic]);

  // const isThereNextField =
  // 	fields.filter( ( field ) => field.id === nextBlockId ).length === 0;

  return (0, _element.createElement)("div", {
    onWheel: swipingHandler,
    className: (0, _classnames.default)('renderer-core-fields-wrapper', {
      active: isActive,
      'is-moving-up': isAnimating && currentBlockIndex < lastActiveBlockIndex,
      'is-moving-down': isAnimating && currentBlockIndex > lastActiveBlockIndex
    }),
    ref: ref,
    "aria-hidden": isActive ? false : true
  }, (0, _element.createElement)("div", handlers, fields.map((field, index) => {
    const isActive = currentBlockId === field.id;
    return (0, _element.createElement)(_fieldRender.default, {
      key: `${field.id}`,
      id: field.id,
      shouldBeRendered: fieldsToRender.includes(field.id),
      isActive: isActive,
      isCurrentBlockSafeToSwipe: isActive ? isCurrentBlockSafeToSwipe : true,
      isLastField:
      // isThereNextField &&
      index === fields.length - 1,
      next: () => {
        if (isCurrentBlockValid) {
          goNextReally();
        } else {
          setIsCurrentBlockSafeToSwipe(false);
        }
      }
    });
  })));
};
var _default = FieldsWrapper;
exports.default = _default;
//# sourceMappingURL=index.js.map